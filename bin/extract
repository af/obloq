#!/usr/bin/env coffee

fs = require("fs")
path = require("path")
markdown = require("markdown").markdown
mustache = require("mustache")
stylus = require("stylus")
nib = require("nib")
coffeescript = require("coffee-script")
finder = require("findit").find(process.cwd() + "/bloqs")

output_files = {}

relative = (infilename) ->
    return 'build' + infilename.split(process.cwd() + '/bloqs')[1] if infilename[0] is '/'
    infilename

outfilename = (infilename, ext) ->
  relativepath = relative(infilename)
  relativepath.split(path.extname(relativepath))[0] + ext

ensurepath = (relpath) ->
  parts = relpath.split("/")
  parts.pop()
  buildpath = ""
  while parts.length
    buildpath = path.join(buildpath, parts.shift())
    fs.mkdirSync buildpath, "0755"  unless path.existsSync(buildpath)
    
toHTMLTree = (filename) ->
  try
    text = fs.readFileSync filename, "utf-8"
    tree = markdown.toHTMLTree(text)
    html = markdown.toHTML(text)
    walk tree, codeExcerpt
    outpath = outfilename(filename, ".html")
    ensurepath outpath
    writeIfChanged(outpath, html)
  catch e
    console.log "There was a problem processing file %s", filename
    throw e

fileUnchanged = (outpath, text) ->
    if not text?
        console.log('no text at all for %s', outpath)
        return true
    return false unless path.existsSync(outpath)
    stats = fs.statSync(outpath)
    return false unless stats.isFile()
    return false unless stats.size is new Buffer(text, 'utf-8').length
    return false unless fs.readFileSync(outpath, 'utf-8') is text
#     console.log('writing %s', outpath)
    return true


writeIfChanged = (outpath, text) ->
    unless fileUnchanged(outpath, text)
        fs.writeFileSync(outpath, text)


writefiles = ->
  concatenated_js = []
  concatenated_css = []
  for outpath, outtext of output_files
    filetype = path.extname(outpath)[1..]
    contents = output_files[outpath].join("\n\n")
    if filetype in [ "stylus", "coffee", "md", "markdown", "mustache", "json", "sketch" ]
      fs.writeFile outpath, contents
      processor[filetype] outpath, contents
  for outpath, outtext of output_files
    filetype = path.extname(outpath)[1..]
    contents = output_files[outpath].join("\n\n")
    if filetype in [ "html", "css", "js" ]
      writeIfChanged(outpath, processor[filetype](outpath, contents))
      if filetype is 'js'
        concatenated_js.push(contents)
      if filetype is 'css'
        concatenated_css.push(contents)
  writeIfChanged('public/js/script.js', concatenated_js.join('\n\n'));
  writeIfChanged('public/css/style.js', concatenated_css.join('\n\n'));

ttype = (obj) ->
  t = typeof obj
  t = "array"  if Array.isArray(obj)
  t

walk = (tree, fn) ->
  switch ttype(tree)
    when "object"
      for key of tree
        fn key, tree[key]
        walk tree[key], fn
    when "array"
      if tree.length == 2
        fn tree[0], tree[1]
        walk tree[1], fn
      else
        tree.forEach (subtree) ->
          walk subtree, fn
    else

stash_fragment = (filename, fragment, processed) ->
  fragment = fragment.split("\n")[2..].join("\n")  unless processed
  output_files[filename] = []  unless output_files[filename]
  output_files[filename].push fragment

codeExcerpt = (name, text) ->
  if /.*code.*/.test(name)
    lines = text.trim().split("\n")
    parsedline = lines[0].match(/file\: +(.*)/)
    unless parsedline
      throw new Error("no filename found for " + lines.length + " lines of code")
    filename = parsedline[1]
    ext = path.extname(filename)
    base = path.basename(filename, ext)
    switch ext
        when '.css'
            outpath = 'public/css/mystyles/' + base + ext
        when '.js'
            outpath = 'public/js/mylibs/' + base + ext
        when '.sjs' # marker for server-side javascript
            outpath = 'server/' + base + '.js'
        else
            outpath = "build/" + base + ext
    stash_fragment outpath, text
    
extract = (filename) ->
  ext = path.extname(filename)
  toHTMLTree filename  if ext in [ ".md", ".markdown" ]
  

processor = 
  sketch: (filename, contents) ->
  
  stylus: (filename, contents) ->
    outpath = outfilename(filename, ".css")
    outcontents = ''
    stylus(contents).set("filename", filename).use(nib()).import("nib").render (err, result) ->
      outcontents = result
    
    stash_fragment outpath, outcontents, true
  
  mustache: (filename, contents) ->
  
  coffee: (filename, contents) ->
    outpath = outfilename(filename, ".js")
    outcontents = coffeescript.compile(contents)
    stash_fragment outpath, outcontents, true
  
  markdown: (filename, contents) ->
    outpath = outfilename(filename, ".html")
    outcontents = markdown.toHTML(contents)
    stash_fragment outpath, outcontents, true
  
  md: (filename, contents) ->
    processors.markdown filename, contents
  
  json: (filename, contents) ->
  
  html: (filename, contents) ->
    contents
  
  css: (filename, contents) ->
    contents
  
  js: (filename, contents) ->
    contents

finder.on "file", extract
finder.on "end",  writefiles


